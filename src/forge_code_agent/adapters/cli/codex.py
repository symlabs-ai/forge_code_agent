from __future__ import annotations

import os
import shlex
import subprocess
import sys
from collections.abc import Iterable
from dataclasses import dataclass, field

from forge_code_agent.adapters.cli.base import CliExecutor, ProviderAdapter
from forge_code_agent.domain.errors import ProviderExecutionError
from forge_code_agent.domain.events import normalize_stream_line
from forge_code_agent.domain.models import ExecutionRequest, ExecutionResult


@dataclass
class CodexProviderAdapter(ProviderAdapter):
    """
    Adapter Codex-like que usa uma CLI baseada em Python.

    MVP: ainda não integra com um binário externo real; em vez disso,
    usa o próprio interpretador Python como "CLI" para materializar
    o conteúdo gerado, permitindo exercitar o fluxo subprocess-run.
    """

    id: str = "codex"
    executor: CliExecutor = field(default_factory=CliExecutor)

    def _build_command(self, request: ExecutionRequest) -> list[str]:
        """
        Construir comando para execução do provider Codex.

        Modos suportados:
        - modo "real": se FORGE_CODE_AGENT_CODEX_CMD estiver definida, usa esse
          comando como base, acrescentando `-C <workdir>` (quando houver) e o
          prompt como último argumento. Exemplo recomendado:
            codex exec --json --dangerously-bypass-approvals-and-sandbox --skip-git-repo-check
        - modo "simulado" (default em ambientes de teste/offline): script
          Python inline que gera conteúdo previsível.
        """
        real_cmd = os.getenv("FORGE_CODE_AGENT_CODEX_CMD")
        if real_cmd:
            base = shlex.split(real_cmd)
            workdir = request.workdir
            if workdir is not None:
                base += ["-C", str(workdir)]
            return base + [request.prompt]

        # Fallback: modo simulado para ambientes sem CLI configurada.
        script = (
            "import sys; "
            "prompt = sys.argv[1]; "
            "provider = sys.argv[2]; "
            "print(f'# generated by {provider}\\n{prompt}')"
        )
        return [sys.executable, "-c", script, request.prompt, request.provider]

    def run(self, request: ExecutionRequest) -> ExecutionResult:
        cmd = self._build_command(request)
        completed = self.executor.run(cmd, timeout=request.timeout)

        if completed.returncode != 0:
            # Erros detalhados são tratados em nível superior via ProviderExecutionError,
            # mas aqui seguimos o contrato e propagamos stdout/stderr via metadata.
            raise ProviderExecutionError(
                "Provider CLI command failed",
                returncode=completed.returncode,
                stderr=completed.stderr,
            )

        content = completed.stdout
        raw_events: list[dict] = []
        for line in content.splitlines():
            raw_events.extend(normalize_stream_line(request.provider, line))
        return ExecutionResult(
            status="success",
            provider=request.provider,
            content=content,
            raw_events=raw_events,
            metadata={
                "workdir": str(request.workdir) if request.workdir is not None else None,
                "command": cmd,
            },
        )

    def stream(self, request: ExecutionRequest) -> Iterable[dict]:
        """
        Executar streaming via subprocess.Popen, emitindo chunks em ordem.

        Modos suportados:
        - modo "real": se FORGE_CODE_AGENT_CODEX_STREAM_CMD estiver definida,
          usa esse comando como base, acrescentando `-C <workdir>` (quando
          houver) e o prompt como último argumento. Exemplo recomendado:
            codex exec --json --dangerously-bypass-approvals-and-sandbox --skip-git-repo-check
          As linhas de stdout (JSONL ou texto) são emitidas incrementalmente.
        - modo "simulado" (default): script Python simples que escreve todo o
          conteúdo no stdout; em seguida, quebramos a string em dois eventos
          para manter o contrato de streaming dos testes BDD.
        """
        real_cmd = os.getenv("FORGE_CODE_AGENT_CODEX_STREAM_CMD")
        if real_cmd:
            base = shlex.split(real_cmd)
            workdir = request.workdir
            if workdir is not None:
                base += ["-C", str(workdir)]
            cmd = base + [request.prompt]

            try:
                proc = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                )
            except OSError as exc:  # pragma: no cover - erro raro de ambiente
                raise ProviderExecutionError("Failed to start provider CLI process", stderr=str(exc)) from exc

            assert proc.stdout is not None
            try:
                for line in proc.stdout:
                    if not line:
                        continue
                    yield {"content": line, "end": False}
                stdout_data, stderr_data = proc.communicate(timeout=request.timeout)
            except subprocess.TimeoutExpired as exc:  # pragma: no cover
                proc.kill()
                raise ProviderExecutionError("Provider CLI command failed during stream() (timeout)", stderr=str(exc)) from exc

            if proc.returncode not in (0, None):
                raise ProviderExecutionError(
                    "Provider CLI command failed during stream()",
                    returncode=proc.returncode,
                    stderr=stderr_data,
                )

            # Emite evento final marcando o fim do stream.
            yield {"content": "", "end": True}
            return

        # Fallback: modo simulado para ambientes sem CLI configurada.
        script = (
            "import sys; "
            "prompt = sys.argv[1]; "
            "provider = sys.argv[2]; "
            "print(f'# streamed by {provider}\\n{prompt}')"
        )
        cmd = [sys.executable, "-c", script, request.prompt, request.provider]

        try:
            proc = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )
        except OSError as exc:  # pragma: no cover - erro raro de ambiente
            raise ProviderExecutionError("Failed to start provider CLI process", stderr=str(exc)) from exc

        stdout_data, stderr_data = proc.communicate(timeout=request.timeout)

        if proc.returncode not in (0, None):
            raise ProviderExecutionError(
                "Provider CLI command failed during stream()",
                returncode=proc.returncode,
                stderr=stderr_data,
            )

        content = stdout_data
        midpoint = max(1, len(content) // 2)
        yield {"content": content[:midpoint], "end": False}
        yield {"content": content[midpoint:], "end": True}
