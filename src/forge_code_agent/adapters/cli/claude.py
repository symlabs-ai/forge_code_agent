from __future__ import annotations

import os
import shlex
import subprocess
import sys
from collections.abc import Iterable
from dataclasses import dataclass, field

from forge_code_agent.adapters.cli.base import CliExecutor, ProviderAdapter
from forge_code_agent.domain.errors import ProviderExecutionError
from forge_code_agent.domain.events import normalize_stream_line
from forge_code_agent.domain.models import ExecutionRequest, ExecutionResult


@dataclass
class ClaudeProviderAdapter(ProviderAdapter):
    """
    Adapter Claude Code-like baseado em CLI.

    MVP: reutiliza o mesmo padrão de script Python inline do adapter Codex,
    variando apenas o identificador de provider. Em fases futuras pode ser
    ligado a uma CLI real.
    """

    id: str = "claude"
    executor: CliExecutor = field(default_factory=CliExecutor)

    def _build_command(self, request: ExecutionRequest) -> list[str]:
        """
        Construir comando para execução do provider Claude.

        Modos suportados:
        - modo "real": se FORGE_CODE_AGENT_CLAUDE_CMD estiver definida, usa esse
          comando como base, acrescentando `--add-dir <workdir>` (quando houver)
          e `-- "prompt"` ao final. Exemplo recomendado:
            claude -p --output-format json --dangerously-skip-permissions
        - modo "simulado" (default em ambientes de teste/offline): script
          Python inline que gera conteúdo previsível.
        """
        base_cmd = os.getenv("FORGE_CODE_AGENT_CLAUDE_CMD")
        if base_cmd:
            base = shlex.split(base_cmd)
            workdir = request.workdir
            if workdir is not None:
                base += ["--add-dir", str(workdir)]
            base += ["--", request.prompt]
            return base

        # Fallback: modo simulado.
        script = (
            "import sys; "
            "prompt = sys.argv[1]; "
            "provider = sys.argv[2]; "
            "print(f'# generated by {provider}\\n{prompt}')"
        )
        return [sys.executable, "-c", script, request.prompt, request.provider]

    def run(self, request: ExecutionRequest) -> ExecutionResult:
        cmd = self._build_command(request)
        completed = self.executor.run(cmd, timeout=request.timeout)

        if completed.returncode != 0:
            raise ProviderExecutionError(
                "Provider CLI command failed",
                returncode=completed.returncode,
                stderr=completed.stderr,
            )

        content = completed.stdout
        raw_events: list[dict] = []
        for line in content.splitlines():
            raw_events.extend(normalize_stream_line(request.provider, line))
        return ExecutionResult(
            status="success",
            provider=request.provider,
            content=content,
            raw_events=raw_events,
            metadata={
                "workdir": str(request.workdir) if request.workdir is not None else None,
                "command": cmd,
            },
        )

    def stream(self, request: ExecutionRequest) -> Iterable[dict]:
        """
        Streaming com suporte a modo real (quando configurado) e simulado.

        - modo "real": se FORGE_CODE_AGENT_CLAUDE_STREAM_CMD estiver definida,
          usa esse comando como base, acrescentando `--add-dir <workdir>` e
          `-- "prompt"`. Exemplo recomendado:
            claude -p --output-format stream-json --verbose --dangerously-skip-permissions
          As linhas emitidas em stdout (JSONL) são encaminhadas incrementalmente.
        - modo "simulado": script Python inline que emite o conteúdo em dois
          chunks, preservando a ordem.
        """
        base_cmd = os.getenv("FORGE_CODE_AGENT_CLAUDE_STREAM_CMD")
        if base_cmd:
            base = shlex.split(base_cmd)
            workdir = request.workdir
            if workdir is not None:
                base += ["--add-dir", str(workdir)]
            base += ["--", request.prompt]

            try:
                proc = subprocess.Popen(
                    base,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                )
            except OSError as exc:  # pragma: no cover
                raise ProviderExecutionError("Failed to start provider CLI process", stderr=str(exc)) from exc

            assert proc.stdout is not None
            try:
                for line in proc.stdout:
                    if not line:
                        continue
                    yield {"content": line, "end": False}
                stdout_data, stderr_data = proc.communicate(timeout=request.timeout)
            except subprocess.TimeoutExpired as exc:  # pragma: no cover
                proc.kill()
                raise ProviderExecutionError("Provider CLI command failed during stream() (timeout)", stderr=str(exc)) from exc

            if proc.returncode not in (0, None):
                raise ProviderExecutionError(
                    "Provider CLI command failed during stream()",
                    returncode=proc.returncode,
                    stderr=stderr_data,
                )

            # Evento final marcando o fim do stream.
            yield {"content": "", "end": True}
            return

        # Fallback: modo simulado.
        script = (
            "import sys; "
            "prompt = sys.argv[1]; "
            "provider = sys.argv[2]; "
            "print(f'# streamed by {provider}\\n{prompt}')"
        )
        cmd = [sys.executable, "-c", script, request.prompt, request.provider]

        try:
            proc = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )
        except OSError as exc:  # pragma: no cover
            raise ProviderExecutionError("Failed to start provider CLI process", stderr=str(exc)) from exc

        stdout_data, stderr_data = proc.communicate(timeout=request.timeout)

        if proc.returncode not in (0, None):
            raise ProviderExecutionError(
                "Provider CLI command failed during stream()",
                returncode=proc.returncode,
                stderr=stderr_data,
            )

        content = stdout_data
        midpoint = max(1, len(content) // 2)
        yield {"content": content[:midpoint], "end": False}
        yield {"content": content[midpoint:], "end": True}
