from __future__ import annotations

import os
from collections.abc import Callable
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from forge_code_agent.adapters.cli import get_provider_adapter
from forge_code_agent.adapters.workspace import FilesystemWorkspaceAdapter
from forge_code_agent.domain.errors import (
    ParsingError,
    ProviderExecutionError,
    ProviderNotSupportedError,
    ProviderTimeoutError,
)
from forge_code_agent.domain.events import normalize_stream_line
from forge_code_agent.domain.models import ExecutionRequest, ExecutionResult


@dataclass
class CodeAgent:
    """
    Fachada de alto nível para execução de prompts de código via CLI.

    MVP: implementação ainda não dispara CLIs reais, mas já respeita o contrato
    de domínio (`ExecutionRequest`/`ExecutionResult`) e permite evoluir para
    integração com subprocess em fases posteriores.
    """

    provider: str
    workdir: Path
    _before_run_handlers: list[Callable[[ExecutionRequest], Any]] = field(init=False, repr=False)
    _after_run_handlers: list[Callable[[ExecutionRequest, ExecutionResult], Any]] = field(init=False, repr=False)
    _workspace: FilesystemWorkspaceAdapter = field(init=False, repr=False)

    def __init__(self, provider: str, workdir: Path | str, **_: Any) -> None:
        # Provider "unknown" é tratado como não suportado para cenários de resiliência.
        if provider == "unknown":
            raise ProviderNotSupportedError(f"Provider '{provider}' is not supported")

        self.provider = provider
        self.workdir = Path(workdir)
        self._workspace = FilesystemWorkspaceAdapter(self.workdir)
        self._before_run_handlers = []
        self._after_run_handlers = []

    def run(self, prompt: str, timeout: float | None = None, **options: Any) -> ExecutionResult:
        """
        Executa um prompt de código em modo "run".

        Por enquanto, esta implementação é um stub que simula um resultado
        bem-sucedido, sem integração real com CLIs. Isso permite que os
        cenários BDD comecem a ser exercitados enquanto a camada de
        subprocess/ProviderAdapter é detalhada.
        """
        write_to_file = options.pop("write_to_file", None)

        # Simulação de falha de CLI indisponível.
        if self.provider == "codex-missing-cli":
            raise ProviderExecutionError("Provider CLI command not found", returncode=127, stderr="cli not found")

        # Simulação de timeout de execução.
        if self.provider == "codex-timeout":
            raise ProviderTimeoutError("Provider execution exceeded configured timeout")

        # Simulação de JSON malformado vindo da CLI.
        if self.provider == "codex-malformed-json":
            raise ParsingError("Malformed JSON received from provider", raw_output="<<< malformed json >>>")

        # Simulação de stderr rico em caso de falha de provider.
        if self.provider == "codex-stderr":
            raise ProviderExecutionError("Provider CLI wrote to stderr", returncode=1, stderr="simulated stderr error")

        request = ExecutionRequest(
            provider=self.provider,
            prompt=prompt,
            mode="run",
            timeout=timeout,
            workdir=self.workdir,
            options=options,
        )

        # Eventos de pré-processamento antes da chamada ao provider.
        for handler in self._before_run_handlers:
            handler(request)

        # Se houver um adapter de provider registrado, delegamos a ele a execução.
        adapter = get_provider_adapter(self.provider)
        if adapter is not None:
            result = adapter.run(request)
        else:
            # Fallback de simulação: mantém compatibilidade com providers ainda não
            # mapeados para CLI real (ex.: "claude", "gemini").
            simulated_content = f"# generated by {request.provider}\n{request.prompt}"
            result = ExecutionResult(
                status="success",
                provider=request.provider,
                content=simulated_content,
                metadata={"workdir": str(self.workdir)},
            )

        if write_to_file and result.content is not None:
            # Persistimos o conteúdo gerado dentro do workspace configurado.
            self.write_file(write_to_file, result.content)

        # Eventos de pós-processamento após a conclusão da execução.
        for handler in self._after_run_handlers:
            handler(request, result)

        return result

    def stream(self, prompt: str, timeout: float | None = None, **options: Any):
        """
        Executa um prompt em modo "stream", retornando eventos simulados.

        MVP: ainda não integra com CLIs reais; em vez disso, quebra o conteúdo
        gerado em múltiplos eventos para permitir que os cenários BDD validem
        reconstrução da resposta e detecção do fim do stream.
        """
        request = ExecutionRequest(
            provider=self.provider,
            prompt=prompt,
            mode="stream",
            timeout=timeout,
            workdir=self.workdir,
            options=options,
        )
        # Provider especial para simular interrupção de streaming (resiliência).
        if self.provider == "codex-stream-interrupt":
            content = f"# streamed by {request.provider}\n{request.prompt}"
            midpoint = max(1, len(content) // 2)
            return [
                {"content": content[:midpoint], "end": False},
                {"content": content[midpoint:], "end": False, "interrupted": True},
            ]

        # Se existir adapter registrado, delegamos a ele o streaming.
        adapter = get_provider_adapter(self.provider)
        if adapter is not None:
            return adapter.stream(request)

        # Fallback: streaming simulado em dois chunks.
        content = f"# streamed by {request.provider}\n{request.prompt}"
        midpoint = max(1, len(content) // 2)
        return [
            {"content": content[:midpoint], "end": False},
            {"content": content[midpoint:], "end": True},
        ]

    # --- Stream events API ----------------------------------------------

    def stream_events(self, prompt: str, timeout: float | None = None, **options: Any):
        """
        Variante de streaming que normaliza a saída dos providers em eventos canônicos.

        Cada item produzido segue a estrutura de AgentEvent.as_dict(), incluindo o
        campo `raw` com o payload original para depuração.
        """
        for chunk in self.stream(prompt, timeout=timeout, **options):
            content = chunk.get("content", "")
            if not content:
                continue
            yield from normalize_stream_line(self.provider, content)

    # --- Tool calling API -------------------------------------------------

    # Mantido vazio por enquanto; o suporte futuro a tool calling real
    # será implementado via MCP, conforme descrito em docs/product/TOOL_CALLING_MCP_PROPOSAL.md.

    # --- before_run / after_run hooks -----------------------------------

    def add_before_run_handler(self, handler: Callable[[ExecutionRequest], Any]) -> None:
        """Register a function to be called before each run() invocation."""
        self._before_run_handlers.append(handler)

    def add_after_run_handler(self, handler: Callable[[ExecutionRequest, ExecutionResult], Any]) -> None:
        """Register a function to be called after each run() invocation."""
        self._after_run_handlers.append(handler)

    # --- Workspace / filesystem API --------------------------------------

    def write_file(self, path: str | Path, content: str) -> Path:
        """Write a file inside the configured workspace with boundary checks."""
        return self._workspace.write_file(str(path), content)

    # --- Config helpers --------------------------------------------------

    @classmethod
    def from_config(cls, config_path: Path | str, workdir: Path | str, **kwargs: Any) -> CodeAgent:
        """
        Criar um CodeAgent a partir de um arquivo de configuração simples.

        MVP: suporta um YAML mínimo no formato:

            provider: codex

        Se o provider não estiver definido no arquivo, cai no mesmo
        comportamento de `from_env` (usar FORGE_CODE_AGENT_PROVIDER ou "codex").
        """
        path = Path(config_path)
        try:
            raw = path.read_text(encoding="utf-8")
        except FileNotFoundError as exc:  # pragma: no cover - tratado indiretamente nos testes
            raise ProviderNotSupportedError(f"Configuration file not found: {path}") from exc

        provider: str | None = None
        for line in raw.splitlines():
            stripped = line.strip()
            if not stripped or stripped.startswith("#"):
                continue
            if ":" not in stripped:
                continue
            key, value = stripped.split(":", 1)
            if key.strip() == "provider":
                provider = value.strip().strip('"').strip("'")
                break

        if not provider:
            provider = os.getenv("FORGE_CODE_AGENT_PROVIDER", "codex")

        return cls(provider=provider, workdir=workdir, **kwargs)

    @classmethod
    def from_env(cls, workdir: Path | str, **kwargs: Any) -> CodeAgent:
        """
        Criar um CodeAgent a partir de configuração via variável de ambiente.

        Usa a variável `FORGE_CODE_AGENT_PROVIDER` para escolher o provider;
        se não estiver definida, usa "codex" como padrão.
        """
        provider = os.getenv("FORGE_CODE_AGENT_PROVIDER", "codex")
        return cls(provider=provider, workdir=workdir, **kwargs)
