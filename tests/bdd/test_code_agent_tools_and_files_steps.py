from pathlib import Path
from typing import Any

import pytest
from pytest_bdd import given, scenarios, then, when

from forge_code_agent.runtime.agent import CodeAgent

scenarios("../../specs/bdd/10_forge_core/11_code_agent_tools_and_files.feature")


@pytest.fixture
def clean_working_directory(tmp_path: Path) -> Path:
    """Workspace vazio para cenários de files/tools."""
    # Garante que o diretório esteja vazio no início do cenário
    for child in tmp_path.iterdir():
        if child.is_dir():
            for sub in child.rglob("*"):
                if sub.is_file():
                    sub.unlink()
        else:
            child.unlink()
    return tmp_path


@given("a clean working directory configured for the project", target_fixture="workdir")
def given_clean_workdir(clean_working_directory: Path) -> Path:
    return clean_working_directory


@given("there is a CodeAgent configured with an empty working directory", target_fixture="code_agent")
def given_code_agent_with_empty_workdir(clean_working_directory: Path) -> CodeAgent:
    # Garantimos que o diretório está vazio (fix de segurança adicional).
    assert not any(clean_working_directory.iterdir())
    return CodeAgent(provider="codex", workdir=clean_working_directory)


@when("the developer executes a prompt that generates a code module", target_fixture="execution_result")
def when_developer_executes_prompt_generating_module(code_agent: CodeAgent) -> Any:
    prompt = "def generated():\n    return 'ok'"
    return code_agent.run(prompt, write_to_file="generated_module.py")


@then("the runtime creates the corresponding files inside the working directory")
def then_runtime_creates_files_inside_workdir(code_agent: CodeAgent, execution_result: Any):
    target = code_agent.workdir / "generated_module.py"
    assert target.is_file()


@then("the file contents reflect the code generated by the engine")
def then_file_contents_reflect_generated_code(code_agent: CodeAgent):
    target = code_agent.workdir / "generated_module.py"
    content = target.read_text(encoding="utf-8")
    assert "generated" in content


@then("no files are written outside the configured workspace")
def then_no_files_written_outside_workspace(code_agent: CodeAgent):
    # Como a implementação sempre escreve dentro do workdir, basta garantir que
    # o arquivo esperado está dentro dele.
    target = code_agent.workdir / "generated_module.py"
    assert code_agent.workdir in target.resolve().parents


@given('a CodeAgent configured with working directory "/project"', target_fixture="code_agent")
def given_code_agent_with_custom_workdir() -> CodeAgent:
    # Usamos um path lógico; a segurança deve ser verificada antes de qualquer escrita.
    return CodeAgent(provider="codex", workdir=Path("/project"))


@given('the engine attempts to generate a file with path "../outside/file.py"', target_fixture="malicious_path")
def given_engine_attempts_outside_path() -> str:
    return "../outside/file.py"


@when("the runtime processes the file write request", target_fixture="write_error")
def when_runtime_processes_file_write_request(code_agent: CodeAgent, malicious_path: str):
    from forge_code_agent.domain.errors import WorkspaceSecurityError

    try:
        code_agent.write_file(malicious_path, "print('should not be written')")
    except WorkspaceSecurityError as exc:  # expected path
        return exc
    return None


@then("the runtime rejects the write operation")
def then_runtime_rejects_write(write_error):
    assert write_error is not None


@then("the developer receives an error indicating forbidden path traversal")
def then_developer_receives_forbidden_path_error(write_error):
    assert "path traversal" in str(write_error).lower()
